{
  
    
        "post0": {
            "title": "Convolución de matrices para procesado de imágenes",
            "content": ". Una de las aplicaciones más importantes de la convolución de matrices es el procesamiento de imágenes, mediante un proceso iterativo que recorre cada pixel de una imagen, obteniendo valores de los pixeles circundantes y aplicando una transformación a estos datos, se puede obtener información relevante y realzar o mejorar aspectos que no son claramente notorios a simple vista o que son difíciles de procesar sin un tratamiento previo. . En formato digital, una imagen de mapa de bits tiene la estructura de una matriz de dos dimensiones, puede representarse como una función $f(x,y)$ donde $x$ e $y$ nos dan la posición de cada pixel y la función nos devuelve su &#39;color&#39;. Para visualizar el color de este pixel, se usa un vector de tres valores que representan la intensidad de los colores rojo, verde y azul, cada uno tomando valores desde 0 a 255. . Entonces, la convolución de matrices consiste en la sumatoria de la multiplicación de cada elemento de un kernel predefinido con cada elemento de una sub matriz (sección de una matriz más grande) como se describe en la siguiente ecuación: . $$ g(x,y)=w*f(x,y)={1 over c} sum_{dx=-a}^{a} sum_{dy=-b}^{b}w(dx,dy)f(x+dx,y+dy) $$Donde $f(x,y)$ es la imagen original, $w$ el kernel de filtrado y $g(x,y)$ la imagen resultante del proceso de convolución, $a$ y $b$ representan la distancia desde el elemento central del kernel hacia los bordes, de modo que definen el tamaño del kernel, en este trabajo usaremos una matriz de $3 times3$, por lo que $dx$ y $dy$ tomarán valores discretos en el rango $[-1,1]$ en este caso. La variable $c$ es el factor de normalización, su valor es la suma de los elementos del kernel, lo que nos permite mantener el valor promedio de nivel de color. . Esta será la ecuación que desarrollaremos de manera funcional, para luego comprobar su funcionamiento con algunas matrices kernel conocidas para evaluar los resultados que obtengamos. . Para esto usaremos las siguientes bibliotecas que importamos a continuación: Pillow, numpy, matplotlib y también usaremos algunas funciones de functools. . import matplotlib.image as img from PIL import Image from functools import reduce import numpy as np . Definici&#243;n de funciones . Uno de los principios de la programación funcional consiste en crear funciones que se asemejen a funciones matemáticas, esto es, que los datos que retornen representen una transformación de sus datos de entrada, sin causar modificaciones en otras partes del programa ni verse afectadas por otros factores externos. Para esto, usaremos las funciones lambda de python, que ayudarán a mantener una buena legibilidad. . Como la matriz de la imagen contiene vectores de tres elementos, tendremos que definir una función para realizar la multiplicación de un entero con una tupla, usando funciones lambda tendremos: . # multiplicación de un entero y una tupla mult_int_tuple = lambda i, a, b, c : (i*a, i*b, i*c) . Como vemos, esta función toma cuatro argumentos y los devuelve transformados, sin realizar asignaciones de variables. En programación funcional no se usan variables, sino funciones que devuelven valores constantes, por tanto no pueden hacerse asignaciones a estas una vez definidas. . Para evitarnos la necesidad de hacer asignaciones de variables, haremos uso en muchos casos de una característica de python: unpacking que consiste en realizar asignaciones a tuplas, de modo que se pueden hacer asignaciones de varios valores a la vez o incluso recibir en una tupla los valores de una función que devuelva más de un valor. Pero dijimos que no usaríamos asignaciones, así que usaremos otro aspecto del unpacking, en este caso al llamar a funciones, en lugar de llamar a la función mult_int_trip con cuatro argumentos, lo haremos con dos: un entero y una tupla de tres elementos, para esto, llamaremos a la función con la siguiente sintaxis: . mult_int_trip(i, *t) . Donde i es un entero y t una tupla, nótese que el símbolo de asterisco (*) delante de t nos permite mapear los tres valores de la tupla t en las variables a, b y c de la función, de no incluirlo, tendríamos errores en la ejecución, ya que la función espera cuatro argumentos y estaríamos enviando sólo dos. . De forma similar a la anterior, definiremos otras funciones que requeriremos en el futuro. . # división de una tupla por un entero div_tuple_int = lambda i, a, b, c : (a/i, b/i, c/i) # suma de un entero a los elementos de una tupla sum_tuple_int = lambda i, a, b, c : (a+i, b+i, c+i) # suma de dos tuplas sum_tuples = lambda a, b : (a[0]+b[0], a[1]+b[1], a[2]+b[2]) . Además tomaremos algunos otros detalles en cuenta, ya que se trata de colores formados por tres valores (rojo, verde y azul), tendremos que controlar que no se salgan del rango $[0, 255]$. para esto crearemos las siguientes funciones: . ib = lambda x : 0 if x &lt; 0 else 255 if x &gt; 255 else x in_bounds = lambda x, y, z : (ib(x), ib(y), ib(z)) . La primera función, ib, recibe un número y comprueba que se encuentre en el rango correcto, si es menor que 0 devolverá 0 y si es mayor que 255 devolverá 255, para los demás casos devolverá el mismo valor de entrada. En la segunda función, realizamos la misma tarea pero para una tupla de tres elementos, haciendo uso de la función ib para cada elemento. . Iteraci&#243;n en programaci&#243;n funcional . La iteración en programación funcional no se realiza usando bucles for o while, como dijimos antes, no se permite la asignación de variables, y estos bucles suelen depender de la variación de un contador el control de sus iteraciones, en lugar de bucles suele usarse recursividad, pero en este caso usaremos funciones como map o reduce, que nos permiten aplicar una función a un elemento iterable como una lista o vector, devolviendo otra lista con los valores ya procesados. . En la siguiente imagen podemos ver un ejemplo de la implementación de map sobre una lista, el ejemplo muestra la sintaxis de haskell, un lenguaje de programación puramente funcional, pero python también tiene implementada la función map que podemos usar de la misma manera. . . Es así como haremos el recorrido sobre las matrices y sobre toda la imagen que estaremos tratando, pero en este caso, me tomaré una licencia sobre la fórmula de convolución que vimos al principio, en lugar de tomar dos matrices y aplicar la convolución en cada fila y columna, tomaremos dos listas que contengan los mismos elementos, esto sólo por simplicidad, ya que el resultado será exactamente el mismo. . Para esto, definiremos una función que reciba como entrada una imagen y las coordenadas de un pixel y nos devuelva una lista de los pixeles circundantes, el orden es importante, tendremos que mantener el mismo orden en el kernel también, de modo que la correspondencia no se vea afectada. . get_surroundings = lambda image, row, col : [image[row-1][col-1], image[row][col-1], image[row+1][col-1], image[row-1][col], image[row][col], image[row+1][col], image[row-1][col+1], image[row][col+1], image[row+1][col+1]] . Ya que estaremos aplicando una función a cada elemento de dos listas, también definiremos la función zipWith, esta función nos permitirá realizar operaciones de manera directa en dos vectores sin tener que iterar sobre ellos (al menos no de manera explícita). . zipwith_tuples = lambda f, li, lt : [f(i, *t) for (i, t) in zip(li, lt)] . Esta función, toma como argumentos una función f, una lista de enteros li y una lista de tuplas lt, y devuelve una lista que definimos usando la sintaxis de listas de comprensión de python, cuyos elementos son resultado de aplicar la función f sobre un par de elementos i y t que obtendremos de la unión - elemento a elemento - de las listas li y lt. . Esta unión la realiza la función zip que devuelve una lista de tuplas en que el primer elemento pertenece a la primera lista y el segundo a la segunda lista. . Funci&#243;n convoluci&#243;n . Ahora definimos la función que realizará la convolución como indica la fórmula que vimos anteriormente. Siendo innecesariamente rigurosos con la programación funcional, podríamos definir nuestra función de convolución de esta forma: . convolution = lambda arri, arrt, factor, offset : sum_tuple_int(offset, *div_tuple_int(factor, *reduce(sum_tuples, zipwith_tuples(mult_int_tuple, arri, arrt)))) . Pero para hacerla un poco más legible, me tomaré la libertad de definirla de la siguiente manera: . def convolution(arri, arrt, factor, offset): trip = reduce(sum_tuples, zipwith_tuples(mult_int_tuple, arri, arrt)) trip = div_tuple_int(factor, *trip) trip = sum_tuple_int(offset, *trip) return trip . De todos modos, aún se cumple que cuando la función sea llamada con los mismos parámetros, devuelva la misma respuesta ya que no realizamos cambios en ninguna variable. . Esta función recibe como parámetros las dos matrices a operar, el factor por el que dividiremos el resultado, y un offset que podremos usar para controlar el brillo que tenga la imagen, si es que después del proceso este varía. Este es un valor que sumaremos a cada color de cada pixel. . Finalmente definimos una función más, donde haremos la iteración por cada pixel de la imagen ejecutando la función convolution, esta función recibirá como argumentos una imagen, el kernel que elijamos, el factor y el offset, para devolvernos una nueva imagen procesada. . def make_convolution(image_file, kernel, factor, offset): (height, width, dat) = image_file.shape image = image_file.tolist() image2 = [[[0,0,0] for j in range(width)] for i in range(height)] for row in range(1, height-1): for col in range(1, width-1): arr = get_surroundings(image, row, col) arrt = convolution(kernel, arr, factor, offset) image2[row][col] = in_bounds(*arrt) return image2 . Con esto ya estamos listos para probar el código con una imagen y algunos kernels conocidos. primero abriremos una imagen usando la biblioteca matplotlib que importamos al principio. . image_file = img.imread(&quot;../images/convolution/penguin.jpg&quot;) . Usaremos esta fotografía de Jay Ruzesky como ejemplo: . . Box blur . Básicamente, este kernel saca un promedio de los pixeles circundantes, nótese que al ser una matriz de unos, se sumarán todos los valores numéricos de los pixeles sin ser modificados, para luego ser divididos por el factor que en este caso es nueve. . box_blur = [1, 1, 1, 1, 1, 1, 1, 1, 1] factor = 9 offset = 0 image2 = make_convolution(image_file, box_blur, factor, offset) . La variable image2 es una matriz de pixeles, así que la convertiremos en una imagen, usando numpy, para que la podamos mostrar, haremos esto con cada imagen. . image2_arr = np.asarray(image2, dtype=&quot;uint8&quot;) img_file = Image.fromarray(image2_arr, &#39;RGB&#39;) img_file . Tenemos como resultado una imagen con un filtro blur, quedando un poco más borrosa que la original. . Veamos otros ejemplos. . Blur Gaussiano . El blur Gaussiano consiste en difuminar una imagen usando la función de Gauss, en este caso por supuesto usamos una aproximación, al estar trabajando con valores discretos. . gaussian_blur = [1, 2, 1, 2, 4, 2, 1, 2, 1] factor = 16 offset = 0 image2 = make_convolution(image_file, gaussian_blur, factor, offset) . Sharpen . El filtro sharpen hace lo contrario que un filtro blur, en lugar de difuminar la imagen, trata de darle más definición. . sharpen = [ 0, -1, 0, -1, 5, -1, 0, -1, 0] factor = 1 offset = 0 image2 = make_convolution(image_file, sharpen, factor, offset) . Detecci&#243;n de bordes . Existen varios kernels que, aplicados a una imagen, muestran los bordes de los objetos mostrados en la imagen, basados en la variación del color. . border = [ -1, -1, -1, -1, 8, -1, -1, -1, -1] factor = 1 offset = 0 image2 = make_convolution(image_file, border, factor, offset) . Otro ejemplo de detección de bordes: . border2 = [-1, 0, -1, 0, 4, 0, -1, 0, -1] factor = 1 offset = 0 image2 = make_convolution(image_file, border2, factor, offset) . Observaciones . Para imágenes grandes, esta implementación puede llegar a tomar mucho tiempo, una solución empleando programación dinámica podría reducir notoriamente el tiempo de ejecución. . El efecto de los filtros varía notoriamente según el tamaño de la imagen, en imágenes muy grandes su efecto casi no se aprecia, para corregir esto, sería necesario ampliar las dimensiones del kernel. . Referencias . Giménez Palomares, F., Monsoriu Serrá, J., &amp; Alemany Martínez, E. (2016). Aplicación de la convolución de matrices al filtrado de imágenes. Modelling in Science Education and Learning, 9(1), 97-108. doi:https://doi.org/10.4995/msel.2016.4524 . Ludwig, J. (2013). Image convolution. Portland State University. .",
            "url": "https://izurietajr.github.io/blog/python/jupyter/functional%20programming/2020/06/18/convolution.html",
            "relUrl": "/python/jupyter/functional%20programming/2020/06/18/convolution.html",
            "date": " • Jun 18, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master- badges: true- comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . #collapse-hide import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . #collapse-show cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # single-value selection over [Major_Genre, MPAA_Rating] pairs # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(movies).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(movies).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=alt.Y(&#39;IMDB_Rating:Q&#39;, axis=alt.Axis(minExtent=30)), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=600, height=400 ) . Example 3: More Tooltips . # select a point for which to provide details-on-demand label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=700, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; df = pd.read_json(movies) # display table with pandas df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://izurietajr.github.io/blog/jupyter/2020/06/17/test.html",
            "relUrl": "/jupyter/2020/06/17/test.html",
            "date": " • Jun 17, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Edición de documentos con groff",
            "content": "Siempre me ha gustado hacer las cosas de la manera complicada. . Pero no me explico bien, en realidad, lo que me gusta es complicarme la vida por una hora para ahorrarme muchas otras en el futuro, en ese aspecto soy más bien previsor. . Entre las tareas que pienso que me quitan tiempo está la redacción de documentos, ya sean tareas, informes, reportes, monografías, etc. La tarea de modificar los estilos de un documento para que tuviera la misma apariencia que todos los documentos anteriores, me parece una pérdida de tiempo, así que word o pages no me parecen eficientes. La solución obvia para mí era LaTeX, tendría que ocuparme del estilo de mis documentos una vez y luego podría olvidarme del asunto y ocuparme solamente del contenido, además podría escribir en cualquier editor de texto. . Pero LaTeX pesa 4GB al menos! . Si hay algo que no me gusta es malgastar recursos, y 4GB por un programa para dar estilo a mis documentos no me convencía del todo, y entonces, buscando y buscando, encontré la solución, un pequeño programa, tan sencillo que está instalado por defecto en la mayoría de plataformas Unix, de hecho, si no estás usando Windows, puede que lo tengas instalado y nunca te hayas dado cuenta. . Groff . Básicamente groff inició como un programa llamado runoff, usado para editar documentos y documentación en Unix, con el tiempo fueron aparecieron diferentes versiones y groff es ahora la versión de GNU (‘g’ de GNU y ‘roff’ de run off). . Cómo usarlo? . Groff consiste en un conjunto de ‘macros’, que nos dan la sintaxis de cómo debemos escribir un documento, luego groff lo interpretará y nos dará un documento correctamente formateado y con estilos homogéneos. El macro que usaremos ahora será el macro ms, para revisar su documentación, basta con revisar el manual: man groff_ms, lo que nos dará un detalle de los macros que podemos usar, pero ahora haré un resumen con un ejemplo simple. . [Continuará…] .",
            "url": "https://izurietajr.github.io/blog/unix/2020/06/10/groff.html",
            "relUrl": "/unix/2020/06/10/groff.html",
            "date": " • Jun 10, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://izurietajr.github.io/blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Desarrollador, programador backend, me gusta Python, Django, VueJs y el software libre, aunque disfruto también de cosas privativas. .",
          "url": "https://izurietajr.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://izurietajr.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}